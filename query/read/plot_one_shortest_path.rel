def chart = parse_json["""{
    "$schema": "https://vega.github.io/schema/vega-lite/v5.json",
    "width": 800,
    "height": 500,
    "legend": null,
    "layer": [ {
        "projection": { "type": "albersUsa" },
        "mark": { "type": "geoshape", "fill": "white", "stroke": "black" }
      },
      {
      "projection": {    "type": "albersUsa"},
      "mark": {
          "type":"rule",
          "strokeWidth": 4,
          "color": "orange"},
          "opacity": 0.5,
        "encoding": {
          "longitude": {
            "field": "lon1",
            "type": "quantitative"
          },
          "latitude": {
            "field": "lat1",
            "type": "quantitative"
          },
          "longitude2": {"field": "lon2"},
          "latitude2": {"field": "lat2"}
        }},
      {
      "projection": {    "type": "albersUsa"},
        "encoding": {
          "longitude": { "field": "lon", "type": "quantitative" },
          "latitude": { "field": "lat", "type": "quantitative" },
          "size": {"field": "page_rank", "type": "quantitative"}
        },
        "layer": [{
            "mark": {
                "type": "circle",
                "color": "purple"
             }
          }]
        }
      ]}
  """]

  /* old line {
        "encoding": {
          "longitude": { "field": "lon1", "type": "quantitative" },
          "latitude": { "field": "lat1", "type": "quantitative" },
          "longitude": { "field": "lon2", "type": "quantitative" },
          "latitude": { "field": "lat1", "type": "quantitative" }
        },
        "layer": [
            { "mark":
                { "type": "line",
                  "strokeWidth": {"field": "mycolor", "type": "quantitative"}
                  }}]
  }*/

  // "color": { "field": "color", "type": "quantitative"}
  //   {
  //       "field": "mycolor",
  //       "type": "quantitative",
  //       "scale": { "scheme": "blueorange", "domain": [1, 2200] }
  // },
  def chart[:layer, :[], 1, :data, :values] = us_states_geojson
  def chart[:layer, :[], 3, :data, :values, :[]] = json_airports3
  def chart[:layer, :[], 2, :data, :values, :[]] = json_flights
  // def chart[:layer, :[], 3, :mark, :color, :[]] = "#a62b46"

  // def output = json_airports3
  // def output = json_flights[100]
  def output = vegalite:plot[chart]
  // def output = count[major_airports]
  ////////////////////////////////////////////////////////////
  // count[flight_graph:destination]
  // edge: exists(flight_graph:Flight <: flight_graph[edge])

  // flight_graph:Flight

  // def major_nodes = :Flight

  def L =
      string[label], string[k], string[edge1], string[x1], string[edge2], string[x2]
      from label in :Flight, k, edge1, x1, edge2, x2
      where
         exists(xs...:
             flight_graph(label, k) and
             flight_graph(edge1, k, x1, xs...) and
             flight_graph(edge2, k, x2, xs...) and
             edge1 = :origin and
             edge2 = :destination)

  def F =
      string[x1], string[x2]
      from x1, x2
      where
         exists(k, xs...:
             flight_graph(:Flight, k) and
             flight_graph(:origin, k, x1, xs...) and
             flight_graph(:destination, k, x2, xs...)
             )

  def G = x1, x2, k :
         exists(xs...:
             flight_graph(:Flight, k) and
             flight_graph(:origin, k, x1, xs...) and
             flight_graph(:destination, k, x2, xs...)
             )

  def W = x1, x2, flight_weight :
      G(x1, x2, _) and
      flight_weight = count[fi : G(x1, x2, fi)]

  def major_airports = k : flight_graph(:Major, k) and flight_graph(:Airport, k)

  // major airports
  def M = x1, x2, w : W(x1, x2, w) and
      major_airports(x1) and
      major_airports(x2)
  ////////////////////////////////////////////////////////////
  def json_airports[i] =
      (:lat, latf); (:lon, lonf)
      from lat, lon, latf, lonf, state, x
      where
          sort[my_airports](i, x) and
          ^LLA(lat, lon, _, flight_graph:coordinate[x]) and
          ^Degree(latf, lat) and
          ^Degree(lonf, lon)

  def json_airports2[i] =
      (:lat, latf); (:lon, lonf); (:size, w)
      from lat, lon, latf, lonf, state, x, w
      where
          sort[my_airports](i, x) and
          ^LLA(lat, lon, _, flight_graph:coordinate[x]) and
          ^Degree(latf, lat) and
          ^Degree(lonf, lon) and
          (
              (M(x, _, _) and w = count[M[x]]) or
              (not M(x, _, _) and w = 0)
          )


  def json_airports3[i] =
      (:lat, latf); (:lon, lonf); (:page_rank, w)
      from lat, lon, latf, lonf, state, x, w
      where
          sort[my_airports](i, x) and
          ^LLA(lat, lon, _, flight_graph:coordinate[x]) and
          ^Degree(latf, lat) and
          ^Degree(lonf, lon) and
          (
              (PR(x, _) and w = PR[x]) or
              (not PR(x, _) and w = 0.0)
          )

  // standard
  // def flights = i, j, w:
  //     sort[my_airports](i, x) and
  //     sort[my_airports](j, y) and
  //     M(x, y, w) and w > 100 // 200 can be a good number here too
  //     from x, y

  // shortest path
  def flights = i, j, w:
      sort[my_airports](i, x) and
      sort[my_airports](j, y) and
      new_edges(x, y) and w = 1
      from x, y

  def json_flights[i] =
      (:lat1, latf1); (:lon1, lonf1); (:lat2, latf2); (:lon2, lonf2); (:flights, w)
      from latf1, lonf1, latf2, lonf2, x, y, w
      where
          sort[flights](i, x, y, w) and
          json_airports(x, :lat, latf1) and
          json_airports(x, :lon, lonf1) and
          json_airports(y, :lat, latf2) and
          json_airports(y, :lon, lonf2)

  def json_one_flight = json_flights[100]

  def my_airports(x in flight_graph:Airport) =
      flight_graph:located_in(x, state) and
      flight_graph:Major(x)
      from state

  def Edges = x, y : exists(w : M(x, y, w) and w > 0) // can change the value of w > 0
  def Vertex(x) = Edges(x,_) or Edges(_,x)

  def outdegree[nodeid] = count[Edges[nodeid]]
  def mypagerank(nodeid, stepid, prvalue) =
      Vertex(nodeid) and
      stepid = 0 and
      prvalue = 1.0/count[Vertex]

  def damping_factor = 0.85

  def mypagerank(nodeid, stepid, prvalue) =
      stepid = range[1,10,1] and
      Vertex(nodeid) and
      prvalue = (1-damping_factor)/count[Vertex] + damping_factor*tmp_prvalue and
      tmp_prvalue = a + sum[
          neighbor, internal_pr :
              (
                  Edges(neighbor, nodeid) and
                  internal_pr = mypagerank[neighbor, stepid-1]/outdegree[neighbor]
              ) or
              (
                  neighbor = 0 and internal_pr = 0.0
              )
      ] and
      (
          outdegree(nodeid, _) and a = 0.0 or
          not outdegree(nodeid, _) and a = mypagerank[nodeid, stepid-1]
      )
      from a,tmp_prvalue

  def PR = ni, pi : pi = mypagerank[ni, 10] and Vertex(ni)

  ////
  // Shortest path between s and t when they are the same is 0.
  def myshortest_path(s, t, k) = Vertex(s) and Vertex(t) and s = t and k = 0
  // When they are not the same, it is 1+minimum over all shortest paths
  // between s and v, where v and t are adjacent.
  def myshortest_path(s, t, k) =
      s != t and
      k = 1 + Min[v, l: myshortest_path(s, v, l) and Edges(v, t)]

  // def output = Max[x : shortest_path(_, _, x)]
  def suspects = ei, ej : myshortest_path(ei,ej,4)

  @inline def cnil[x] = last[hash[(:nil, x)]]
  @inline def ccons[x, p] = last[hash[(:cons, x, p)]]

  with my_graph use nil, element, tail, length, shortest_path, node, edge, show

  def my_graph:node = Vertex
  def my_graph:edge = Edges
  def my_graph:length[p] = 0, nil(_, p)
  def my_graph:length[p] = 1 + length[tail[p]]
  def my_graph:shortest_distance[x, y] = length[shortest_path[x, y]]
  def my_graph:show[x in node] = string[x]
  def my_graph:show[p] = show[x], nil(x, p) from x
  def my_graph:show[p] = concat[concat[show[element[p]], " -> "], show[tail[p]]]

  def my_graph = (:nil, x, cnil[x]) from x in node
  def my_graph =
      (:shortest_path, x, y, ccons[x, p2]);
      (:element, ccons[x, p2], x);
      (:tail, ccons[x, p2], p2)
      from x, y, p2
      where p2 = argmin[length[p] for p where my_graph:candidate(x, y, p)]

  def my_graph:candidate[x, y] = nil[y], edge(x, y)
  def my_graph:candidate[x, y] = edge[x] . shortest_path[y]

  def shortest_path_enum[x, y] = length[shortest_path[x, y]], shortest_path[x, y]
  def suspects_paths = x, y, l, v : suspects(x , y) and v = shortest_path_enum[x, y, l]
  def one_path = sort[suspects_paths][1]
  def spell_out_edges = x, y, l, e1, e2, e3, e4: one_path(x, y, l, p) and
      e1 = element[p] and
      e2 = element[tail[p]] and
      e3 = element[tail[tail[p]]] and
      e4 = element[tail[tail[tail[p]]]]
      from p

  def new_edges = ei, ej :
      spell_out_edges(_, _, _, ei, ej, _, _) or
      spell_out_edges(_, _, _, _, ei, ej, _) or
      spell_out_edges(_, _, _, _, _, ei, ej)